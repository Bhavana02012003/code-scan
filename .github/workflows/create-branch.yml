name: Create Temporary Branch and Apply Fix

on:
  repository_dispatch:
    types: [create-branch]

permissions:
  contents: write

jobs:
  apply-fix:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Generate GitHub App Token
        id: token
        uses: tibdex/github-app-token@v2
        with:
          app_id: ${{ secrets.GH_APP_ID }}
          private_key: ${{ secrets.GH_APP_PRIVATE_KEY }}
          installation_retrieval_mode: repository
          installation_retrieval_payload: ${{ github.event.client_payload.owner }}/${{ github.event.client_payload.repo }}

      - name: Clone target repo
        run: |
          git clone "https://x-access-token:${{ steps.token.outputs.token }}@github.com/${{ github.event.client_payload.owner }}/${{ github.event.client_payload.repo }}.git" target

      # We only really need the FIXED code now
      - name: Decode fixed code snippet
        run: |
          echo "${{ github.event.client_payload.fixed_code_b64 }}" | base64 --decode > fixed.txt

      - name: Create branch & apply fix (method-level)
        working-directory: target
        run: |
          set -e

          echo "ðŸ‘‰ Checking out target branch..."
          git checkout "${{ github.event.client_payload.target_branch }}"

          echo "ðŸ‘‰ Creating feature branch..."
          git checkout -b "${{ github.event.client_payload.feature_branch }}"

          FILE="${{ github.event.client_payload.file_path }}"
          echo "ðŸ“„ Target file: $FILE"

          # Normalize line endings
          sed -i 's/\r$//' "$FILE"
          sed -i 's/\r$//' ../fixed.txt

          echo "ðŸ§  Building method-level replacer script..."
          cat <<'PERL' > ../apply_fix.pl
          use strict;
          use warnings;

          my $file = shift @ARGV or die "Missing file path\n";
          my $fixed_path = "../fixed.txt";

          # -----------------------------
          # Read fixed snippet
          # -----------------------------
          open my $fh, '<', $fixed_path or die "Cannot open $fixed_path: $!";
          local $/;
          my $fixed = <$fh>;
          close $fh;

          $fixed =~ s/\r//g;

          # -----------------------------
          # Extract methods from FIXED
          # -----------------------------
          my @methods;

          while ($fixed =~ m{
              ^(\s*
                (public|private|global|protected)\s+
                (?:virtual\s+|override\s+|static\s+|abstract\s+|transient\s+|final\s+)*
                [\\w<>\\[\\]]+\\s+
                (\\w+)\\s*              # method name in $3
                \\([^)]*\\)\\s*
                \\{
              )
          }gmsx) {
              my $sig_start = $-[1];
              my $name      = $3;

              # find matching closing brace
              my $brace_pos = index($fixed, '{', $sig_start);
              my $depth = 0;
              my $i = $brace_pos;
              my $end = -1;

              for (; $i < length($fixed); $i++) {
                  my $ch = substr($fixed, $i, 1);
                  $depth++ if $ch eq '{';
                  $depth-- if $ch eq '}';
                  if ($depth == 0 && $i > $brace_pos) {
                      $end = $i + 1; # position AFTER closing brace
                      last;
                  }
              }

              if ($end == -1) {
                  print "âš ï¸  Skipping method $name: unbalanced braces in fixed snippet\n";
                  next;
              }

              my $text = substr($fixed, $sig_start, $end - $sig_start);
              push @methods, { name => $name, text => $text };
          }

          print "Found " . scalar(@methods) . " method(s) in fixed snippet\n";

          # -----------------------------
          # Read original source file
          # -----------------------------
          open my $sfh, '<', $file or die "Cannot open $file: $!";
          local $/;
          my $src = <$sfh>;
          close $sfh;

          $src =~ s/\r//g;

          # -----------------------------
          # Replace each method in source
          # -----------------------------
          METHOD:
          foreach my $m (@methods) {
              my $name     = $m->{name};
              my $new_text = $m->{text};

              if ($src =~ m{
                  ^(\s*
                    (public|private|global|protected)\s+
                    (?:virtual\s+|override\s+|static\s+|abstract\s+|transient\s+|final\s+)*
                    [\\w<>\\[\\]]+\\s+
                    $name\\s*
                    \\([^)]*\\)\\s*
                    \\{
                  )
              }gmsx) {
                  my $sig_start = $-[1];
                  my $brace_pos = index($src, '{', $sig_start);
                  my $depth = 0;
                  my $i = $brace_pos;
                  my $end = -1;

                  for (; $i < length($src); $i++) {
                      my $ch = substr($src, $i, 1);
                      $depth++ if $ch eq '{';
                      $depth-- if $ch eq '}';
                      if ($depth == 0 && $i > $brace_pos) {
                          $end = $i + 1;
                          last;
                      }
                  }

                  if ($end == -1) {
                      print "âš ï¸  Could not find balanced end for method $name in source. Skipping.\n";
                      next METHOD;
                  }

                  substr($src, $sig_start, $end - $sig_start, $new_text);
                  print "âœ… Replaced method $name\n";
              } else {
                  print "â„¹ï¸  Method $name not found in target file. Skipping.\n";
              }
          }

          # -----------------------------
          # Write updated source file
          # -----------------------------
          open my $out, '>', $file or die "Cannot write $file: $!";
          print $out $src;
          close $out;

          PERL

          echo "ðŸ”§ Running method-level replacement..."
          perl ../apply_fix.pl "$FILE"

          echo "// AUTO-FIX APPLIED" >> "$FILE"

          echo "ðŸŽ¯ Committing & pushing changes"
          git config user.email "branch-bot@example.com"
          git config user.name  "Branch Bot"
          git add "$FILE"
          git commit -m "Apply AI Auto Fix" || echo "Nothing to commit"
          git push --set-upstream origin "${{ github.event.client_payload.feature_branch }}"
